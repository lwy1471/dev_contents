# Java의 컬렉션 프레임워크

다수의 데이터를 쉽고 효과적으로 퍼리할 수 있는 클래스의 집합이다.
컬렉션 프레임워크에는 데이터 자료구조의 형테에 따라 아래와 같은 핵심 인터페이스를 정의하고 있다.

1. List 인터페이스: 순서가 있는 목록
1. Set 인터페이스: 순서가 중요하지 않고 중복하지 않는 목록
1. Queue 인터페이스: 먼저 들어온 것이 먼저 나가는 목록
1. (Map 인터페이스): Key-Value 형태로 저장되는 목록

컬렉션 프레임워크를 구성하고 있는 인터페이스 간이 상속 관계는 아래와 같다.
![Collection Interface](./resource/collection_interface.gif)

## Collection 인터페이스의 주요 메소드

Collection 인터페이스에서 제공하는 주오 메소드는 다음과 같다.

|메소드|설명|
|:--|:--|
|boolean add(E e)   | 해당 컬렉션(collection)에 전달된 요소를 추가함. (선택적 기능)|
|void clear()	| 해당 컬렉션의 모든 요소를 제거함. (선택적 기능)|
|boolean contains(Object o)	| 해당 컬렉션이 전달된 객체를 포함하고 있는지를 확인함.|
|boolean equals(Object o)	| 해당 컬렉션과 전달된 객체가 같은지를 확인함.|
|boolean isEmpty()	| 해당 컬렉션이 비어있는지를 확인함.|
|Iterator<E> iterator()	| 해당 컬렉션의 반복자(iterator)를 반환함.|
|boolean remove(Object o)	| 해당 컬렉션에서 전달된 객체를 제거함. (선택적 기능)|
|int size()	| 해당 컬렉션의 요소의 총 개수를 반환함.|
|Object[] toArray()	| 해당 컬렉션의 모든 요소를 Object 타입의 배열로 반환함.

## List 인터페이스

### ArrayList

내부적으로 배열을 이용하여 요소를 저장한다.
인덱스를 통한 요소 검색이 빠르다.
배열의 크기를 동적으로 조절하지만 크기를 늘리기 위해 새로운 배열을 생성하고 기존 요소를 옮길 때 시간이 소요된다.
요소의 추가 및 삭제가 빈번한 경우 성능이 떨어진다.

### LinkedList

내부적으로 연결 리스트를 사용하여 요소를 저장한다.
요소의 저장과 삭제 작업이 빈번한 경우 다음 요소를 가리키는 참조만 변경되므로 빠르게 처리될 수 있다.
인덱스를 통해 접근할 수 없으므로 요소 검색시 성능이 떨어진다.

## Set 인터페이스

Set 인터페이스를 구현한 Set 컬렉션 클래스는 아래와 같은 특징을 가진다.

1. 요소의 저장 순서를 유지하지 않는다.
1. 같은 요소의 중복 저장을 허용하지 않는다.

### HashSet

해시 알고리즘을 사용하여 검색 속도가 매우 빠르다.
내부적으로 HashMap 인스턴스를 이용하여 요소를 저장한다.

### LinkedHashSet

저장 순서가 중요할 경우 HashSet을 상속한 LinkedHashSet을 사용할 수 있다.
LinkedHashSet은 Iteration시 저장한 순서대로 출력이 가능하다.

### TreeSet

데이터가 정렬된 상태로 저장되는 이진 검색 트리의 형태로 요소를 저장한다.
이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠르다.
데이터 정렬을 위해서 compareTo 메소드를 오버라이딩 해야한다.

## Map 인터페이스

Key-Value 방식을 사용하여 데이터를 저장한다. Map 컬랙션은 아래와 같은 특징을 가진다.

1. 요소의 저장 순서를 유지하지 않는다.
1. 키는 중복을 허용하지 않지만 값의 중복은 허용한다.

### HashMap

해시 알고리즘을 사용하여 검색 속도가 매우빠르다.

### TreeMap

데이터를 이진 검색 트리의 형태로 저장한다.
이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠르다.
데이터 정렬을 위해서 compareTo 메소드를 오버라이딩 해야한다.
